## Topic (자바의 Garbage Collection) 2025-11-25

- **주제:** 자바의 Garbage Collection의 구조와 역할 이해


### **Why (왜 사용하는가? 왜 중요한가?)**

> 이 개념이 실무, 설계, 면접에서 중요한 이유를 정리한다.

- **실무**: 개발자가 메모리를 직접 해제하지 않아도 되므로 **메모리 누수(Memory Leak)나 댕글링 포인터(Dangling Pointer)** 같은 치명적인 오류를 줄이고 개발 생산성을 높여줍니다.

- **구조적 의미**: '대부분의 객체는 금방 불필요해진다(Weak Generational Hypothesis)'는 가설을 바탕으로 Heap 영역을 효율적으로 나누어 관리함으로써 **메모리 사용을 최적화**합니다.

- **면접 의도**: JVM의 메모리 관리 구조를 이해하고 있는지, 그리고 GC 발생 시 애플리케이션이 멈추는 **Stop-The-World 현상과 성능 튜닝**에 대한 기본 지식이 있는지 확인하기 위함입니다.


### **Core Concept (핵심 개념 정리)**

> 단순한 정의가 아닌, 의미 + 구조 + 비교 + 조건 중심으로 작성한다.

| **요소**    | **내용**                                                                                                                                                                                                                                                            |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **개념 정의** | JVM의 Heap 영역에서 동적으로 할당했던 메모리 중, **더 이상 참조되지 않는(Unreachable) 객체를 탐지하여 자동으로 제거**하는 메모리 관리 기법.                                                                                                                                                                       |
| **동작 방식** | **Mark and Sweep** 알고리즘을 기본으로 함.<br>  <br><br>1. **Mark**: Root Space(Stack, Method 등)에서 참조하는 객체를 식별.<br><br><br>2. **Sweep**: 참조되지 않은 객체를 힙에서 제거.<br><br>  <br>3. **Generational 구조**: Young Gen(Eden → Survivor 1/2)을 거쳐 오랫동안 살아남은 객체는 Old Gen으로 이동(Promotion). |
| **장점/단점** | **장점**: 개발자가 메모리 관리에 신경 쓰지 않고 비즈니스 로직에 집중 가능.<br><br><br>**단점**: GC 수행 시 **Stop-The-World(STW)**가 발생하여 모든 애플리케이션 스레드가 일시 정지됨 (성능 저하의 원인).                                                                                                                         |
| **필요 조건** | Heap 메모리가 가득 차거나, JVM이 특정 임계치에 도달했다고 판단할 때 실행됨.                                                                                                                                                                                                                   |
| **예시/비교** | **C/C++**: `malloc`/`free`를 통해 수동 관리 (실수 시 오류 발생).<br><br><br>**Python/Swift**: Reference Counting 방식 주로 사용 (순환 참조 문제 발생 가능).<br><br><br>**Java**: Reachability 분석을 통해 순환 참조도 처리 가능.                                                                              |

### **Interview Answer Version (면접 답변식 요약)**

> 30~40초 분량으로, **정의 → 쓰는 이유 → 핵심 효과/특징**순으로 말하듯 요약

"Java의 Garbage Collection은 JVM이 **더 이상 참조되지 않는 메모리를 자동으로 회수**해주는 기능입니다. 이 덕분에 개발자는 메모리 관리에 대한 부담을 덜고 비즈니스 로직에 집중할 수 있습니다.

GC는 주로 **Mark-and-Sweep** 알고리즘을 사용하며, 효율성을 위해 힙 영역을 **Young Generation과 Old Generation**으로 나누어 관리합니다. 다만, GC가 실행되는 동안 애플리케이션이 멈추는 **Stop-The-World** 현상이 발생하므로, 서비스의 특성에 따라 **G1 GC**나 **ZGC** 같은 적절한 알고리즘을 선택하고 튜닝하는 것이 중요합니다."

### **Practical Tip (사용시 주의할 점 or 활용 예)**

> 실제로 어떻게 쓰이며, 잘못 쓰면 어떤 문제가 생기는지를 구체적인 예시로 작성헌다. 사용한 경험이 있다면 해당 코드를 기준으로 정리한다.

- **절대 사용 금지 코드**: `System.gc()`
    
    - 코드 내에서 GC를 강제로 호출하면 무거운 **Full GC**가 발생할 가능성이 높습니다. 이는 전체 시스템을 멈추게 하여 심각한 성능 저하를 일으키므로 절대 명시적으로 호출하면 안 됩니다.
    
- **메모리 누수 주의 (Memory Leak)**
    
    - GC가 있어도 메모리 누수는 발생합니다. 가장 흔한 원인은 `static`으로 선언된 `List`나 `Map`에 객체를 계속 담고 삭제하지 않는 경우입니다. (참조가 남아있어 GC 대상이 되지 않음)
    
    - DB Connection, IO Stream 등 외부 리소스는 반드시 `try-with-resources`나 `finally` 블록에서 `close()` 해야 합니다.
    
- **JVM 옵션 설정**:
    
    - 실무에서는 잦은 힙 크기 조정(Resizing) 오버헤드를 줄이기 위해 초기 힙 크기(`-Xms`)와 최대 힙 크기(`-Xmx`)를 동일하게 설정하는 경우가 많습니다.


### 예상 꼬리 질문 정리

> 추가로 나올 수 있는 질문 3개 이상 생각해보기.

1. **Stop-The-World가 무엇이며, 이것이 발생했을 때 어떤 문제가 생기나요?** (서버 응답 지연, 타임아웃 등)

2. **Young Generation과 Old Generation의 차이점과 객체가 이동하는 과정(Promotion)을 설명해 주세요.** (Minor GC vs Major GC)

3. **Java 8의 Default GC와 Java 11/17 이상의 Default GC 차이를 아시나요?** (Parallel GC vs G1 GC)

4. **G1 GC(Garbage First GC)의 동작 원리에 대해 간략히 설명해 주세요