## Topic (JVM) 2025-11-25

- **주제:** JVM (Java Virtual Machine)의 구조와 역할 이해

### **Why (왜 사용하는가? 왜 중요한가?)**

> 이 개념이 실무, 설계, 면접에서 중요한 이유를 정리한다.

- **실무**: JVM이 없다면 개발자는 리눅스, 윈도우 등 OS마다 다른 버전을 별도로 빌드해야 하며, 메모리 할당/해제를 수동으로 직접 관리해야 하는 생산성 및 안정성 저하 문제가 발생한다.

- **구조적 의미**: 하드웨어/OS와 애플리케이션 사이의 **중개자(Middleware)** 역할을 하여 플랫폼 독립성을 보장하고, JIT 컴파일러를 통해 런타임 시점에 성능을 최적화한다.

- **면접 의도**: 작성한 코드가 실제 메모리에 어떻게 적재되고 실행되는지 이해하고 있는지, 성능 이슈(메모리 누수 등) 발생 시 튜닝할 기초 지식이 있는지 확인한다.


### **Core Concept (핵심 개념 정리)**

> 단순한 정의가 아닌, 의미 + 구조 + 비교 + 조건 중심으로 작성한다.

| **요소**    | **내용**                                                                                                                                                                                                            |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **개념 정의** | Java Bytecode(.class)를 OS가 이해할 수 있는 기계어로 변환하고 실행하는 가상 머신.                                                                                                                                                         |
| **동작 방식** | 1. **Class Loader**: .class 파일을 메모리(Runtime Data Area)에 로드<br><br>  <br>2. **Runtime Data Area**: 실행에 필요한 데이터 저장 (Method, Heap, Stack 등)<br><br><br>3. **Execution Engine**: 로드된 바이트코드를 실행 (Interpreter, JIT, GC) |
| **장점/단점** | **장점**: WORA(Write Once, Run Anywhere) 실현, GC를 통한 자동 메모리 관리<br><br><br>**단점**: C/C++ 대비 실행 속도가 상대적으로 느릴 수 있음 (JIT로 많이 개선됨)                                                                                        |
| **필요 조건** | 실행하려는 OS에 맞는 JRE(Java Runtime Environment)가 설치되어 있어야 함.                                                                                                                                                           |
| **구조 비교** | **Stack**: 메서드 호출 시 생성되는 스레드별 공간 (지역변수 등)<br><br><br>**Heap**: `new` 키워드로 생성된 객체가 저장되는 공유 공간 (GC 대상)                                                                                                              |

### **Interview Answer Version (면접 답변식 요약)**

> 30~40초 분량으로, **정의 → 쓰는 이유 → 핵심 효과/특징**순으로 말하듯 요약

"JVM은 자바 바이트코드를 OS에 맞게 해석하여 실행해주는 가상 머신입니다. 이를 사용하는 가장 큰 이유는 **OS에 독립적인 개발**이 가능하고, 가비지 컬렉션(GC)을 통해 메모리 관리를 자동화해주기 때문입니다. 핵심적으로 코드를 로드하는 Class Loader, 데이터를 저장하는 Runtime Data Area, 그리고 이를 실행하고 최적화하는 Execution Engine으로 구성되어 있습니다."

### **Practical Tip (사용시 주의할 점 or 활용 예)**

> 실제로 어떻게 쓰이며, 잘못 쓰면 어떤 문제가 생기는지를 구체적인 예시로 작성헌다. 사용한 경험이 있다면 해당 코드를 기준으로 정리한다.

- **설정 시 고려 파라미터 (Heap Size)**:
    
    - 서버 배포 시 `-Xms`(초기 힙 크기)와 `-Xmx`(최대 힙 크기)를 동일하게 설정하는 것이 일반적입니다. (런타임 중 힙 크기 변경에 따른 오버헤드 방지)
    
    - 예: `java -Xms2048m -Xmx2048m -jar myapp.jar`
    
- **흔히 발생하는 문제 (OOM)**:
    
    - **OutOfMemoryError**: Heap 영역이 가득 차서 GC로도 공간을 확보할 수 없을 때 발생합니다.
    
    - _원인 예시_: Static 컬렉션(Map, List)에 객체를 계속 담고 비우지 않는 경우(Memory Leak), 혹은 트래픽 대비 힙 메모리를 너무 작게 잡은 경우.
    
- **이걸 모르고 사용하면 생기는 문제**:
    
    - 무분별한 객체 생성으로 인한 잦은 **Stop-the-world** (GC 실행을 위해 애플리케이션이 멈추는 현상) 발생으로 서비스 응답 지연 초래.


### 예상 꼬리 질문 정리

> 추가로 나올 수 있는 질문 3개 이상 생각해보기.

1. **GC(Garbage Collection)의 동작 과정과 주요 알고리즘(G1GC 등)에 대해 설명해 주세요.**

2. **Runtime Data Area 영역 중, 멀티 스레드 환경에서 '공유되는 영역'과 '독립적인 영역'을 구분해 보세요.** (Heap/Method vs Stack/PC Register)

3. **Java 코드가 컴파일되어 실행되기까지의 과정을 상세히 설명해 주세요.** (또는 JIT 컴파일러가 무엇이며 왜 필요한가요?)