# [Java] 객체지향(OOP)이란 무엇이며, 왜 Java는 객체지향 언어인가?

**"Java는 객체지향 언어이다"** 굉장히 많이 들어봤을 것입니다. 하지만 누군가 *"그래서 객체지향이 뭔데? 왜 객체지향 하면 Java가 나와?"* 라고 묻는다면 명쾌하게 답하기 어려울 때가 많습니다.

프로그래밍의 패러다임이 절차지향에서 객체지향으로 변화한 이유와, **Java가 어떻게 객체지향의 대명사가 되었는지** 정리해 보겠습니다.

---

## 1. 서론: 왜 우리는 '객체'를 지향하게 되었나?

초기의 프로그래밍은 **절차지향(Procedural Programming)** 중심이었습니다. 대표적으로 C언어가 있죠. 절차지향은 '물의 흐름'처럼 코드가 순서대로 실행되는 것에 초점을 맞춥니다.

### 절차지향이란?
데이터와 그 데이터를 처리하는 함수가 분리되어 있고, **"어떻게(How) 처리할 것인가"** 인 순차적인 로직에 집중하는 방식입니다. 마치 요리 레시피처럼 1번부터 10번까지 순서대로 실행되는 것이 중요하며, 프로그램 전체가 유기적으로 연결되어 있습니다.

### 절차지향의 한계
컴퓨터가 처리해야 할 명령이 적을 때는 절차지향이 빠르고 직관적입니다. 하지만 소프트웨어의 규모가 거대해지면서 문제가 발생했습니다.
* 코드가 길어지면서 변수와 함수의 관리가 어려워짐 (스파게티 코드).
* 코드의 재사용이 어렵고, 하나를 고치면 연쇄적으로 에러가 발생함.

개발자들은 고민했습니다. **"우리가 사는 현실 세계처럼, 프로그램을 독립된 부품(객체)들의 조립으로 만들 수는 없을까?"**

이러한 고민 끝에 **객체지향 프로그래밍(OOP, Object-Oriented Programming)** 이 등장하게 되었습니다.

---

## 2. 객체지향 프로그래밍(OOP) 핵심 해부

객체지향은 프로그램을 **상태(Data)** 와 **행위(Method)** 를 가진 **'객체(Object)'** 들의 상호작용으로 파악하는 기법입니다.

### 붕어빵 틀(Class)과 붕어빵(Object)
![붕어빵](https://wiki1.kr/images/thumb/b/b4/%EB%B6%95%EC%96%B4%EB%B9%B5%ED%8B%80%EA%B3%BC_%EB%B6%95%EC%96%B4%EB%B9%B5.png/800px-%EB%B6%95%EC%96%B4%EB%B9%B5%ED%8B%80%EA%B3%BC_%EB%B6%95%EC%96%B4%EB%B9%B5.png)

가장 유명한 비유를 들어보겠습니다.
* **Class (클래스):** 붕어빵을 만들기 위한 '틀' (설계도).
* **Object (객체/인스턴스):** 틀을 통해 실제로 만들어진 '붕어빵' (실체).

우리는 붕어빵 틀 하나만 있으면, 팥 붕어빵, 슈크림 붕어빵 등 수많은 객체를 찍어낼 수 있습니다.

#### 객체란?
클래스(설계도)에 의해 **메모리(Heap) 상에 생성된 실제 데이터**입니다. 붕어빵 틀은 하나지만, 거기서 나온 팥 붕어빵과 슈크림 붕어빵은 서로 다른 속성(내용물)을 가진 독립적인 존재입니다. 프로그래밍에서는 이를 **인스턴스(Instance)** 라고도 부릅니다.

### 객체지향의 4대 특성
![객체지향 특성](https://velog.velcdn.com/images/gwjin99/post/c0f82bac-4ea8-428b-b69e-838cc342fd9a/image.png)

Java는 이 4가지 특성을 문법적으로 완벽하게 지원합니다. 이해를 돕기 위해 **RPG 게임의 캐릭터**를 예로 들어보겠습니다.

1. **추상화 (Abstraction):**
    * 복잡한 시스템에서 핵심적인 공통 특징만 추출합니다.
    * *예: 전사, 마법사 모두 '공격한다', '이동한다'는 공통점이 있으므로 `Character`라는 추상적인 개념으로 묶습니다.*
2. **상속 (Inheritance):**
    * 기존 클래스의 기능을 물려받아 재사용합니다.
    * *예: `Character`의 기본 기능을 물려받아 `Warrior`를 만들면 코드를 다시 짤 필요가 없습니다.*
3. **다형성 (Polymorphism):**
    * 같은 이름의 메서드가 상황에 따라 다르게 동작합니다. (Overloading, Overriding)
    * *예: 똑같이 '공격' 버튼을 눌러도 전사는 '칼'을 휘두르고, 마법사는 '불꽃'을 발사합니다.*
4. **캡슐화 (Encapsulation):**
    * 관련된 데이터와 함수를 하나로 묶고, 외부에서 함부로 접근하지 못하게 보호합니다.
    * *예: 캐릭터의 `HP(체력)`를 마음대로 9999로 조작할 수 없게 막고, 오직 `takeDamage()` 메서드를 통해서만 줄어들게 합니다.*

#### Java로 보는 4대 특성

```java
// 1. 추상화: 공통 기능 정의
abstract class Character {
    // 4. 캡슐화: HP는 외부에서 직접 접근 불가 (private)
    private int hp = 100;

    public void takeDamage(int damage) {
        this.hp -= damage;
    }

    // 하위 클래스가 반드시 구현해야 할 공격 방식
    abstract void attack();
}

// 2. 상속: Character의 기능을 물려받음
class Warrior extends Character {
    // 3. 다형성: 전사만의 공격 방식으로 재정의 (Overriding)
    @Override
    void attack() {
        System.out.println("칼로 공격합니다!");
    }
}

class Wizard extends Character {
    // 3. 다형성: 마법사만의 공격 방식으로 재정의
    @Override
    void attack() {
        System.out.println("마법 불꽃 발사!");
    }
}
```

---

## 3. Java는 왜 객체지향 언어인가?

C++이나 Python도 객체지향을 지원하지만, 유독 **Java를 객체지향의 정석**이라고 부르는 이유는 무엇일까요?

### 1) "Class 없이는 아무것도 할 수 없다" (강제성)
C언어나 Python은 함수(Function)만으로도 코드를 짤 수 있습니다. 하지만 **Java는 모든 것이 클래스 내부에 존재해야 합니다.** 심지어 프로그램을 시작하는 `main` 메서드조차 클래스 안에 있어야 합니다. 이는 개발자가 처음부터 '객체 단위'로 사고하도록 강제합니다.

```java
public class Main { // 클래스가 없으면 실행조차 불가능
    public static void main(String[] args) {
        System.out.println("Hello, OOP!");
    }
}
```

### 2) Java 문법과 OOP의 매핑
Java의 문법은 OOP의 4대 특성을 구현하기 위해 설계되었습니다.

| OOP 특징 | Java 문법 키워드 | 설명 |
| :--- | :--- | :--- |
| **캡슐화** | `private`, `getter/setter` | 변수는 숨기고 메서드로 접근 |
| **상속** | `extends` | 부모 클래스의 필드/메서드 상속 |
| **다형성** | `interface`, `@Override` | 구현체를 갈아 끼우기 쉬운 구조 |
| **추상화** | `abstract class`, `interface` | 공통적인 특징만 정의 |

---

## 4. 심화: Java의 동작 방식으로 보는 OOP (Memory)

Java가 진정한 객체지향 언어인 이유는 **메모리 관리 방식(JVM)** 에서도 드러납니다.



### Stack vs Heap
* **Stack 영역:** 메서드의 실행 정보와 기본 타입 변수(`int`, `boolean` 등)가 저장되는 곳입니다. (절차적 실행)
* **Heap 영역:** **`new` 키워드로 생성된 모든 객체(Instance)가 저장되는 곳입니다.**

Java에서 `Car myCar = new Car();`를 실행하면 다음과 같은 일이 일어납니다.

1. **Heap** 영역에 실제 자동차 객체(`new Car()`)가 생성됩니다. (실체)
2. **Stack** 영역에는 그 객체의 위치를 가리키는 리모컨(`myCar`)만 생성됩니다. (참조 변수)

즉, Java는 **메모리 구조 자체를 객체(Heap) 중심으로 설계**하여, 개발자가 포인터 같은 복잡한 메모리 주소 관리 대신 **객체 간의 관계**에만 집중할 수 있게 해줍니다. (feat. Garbage Collector가 안 쓰는 객체는 알아서 정리해 줌)

---

## 5. 결론

**"Java는 객체지향 언어인가?"** 라는 질문에 대한 답은 **"그렇다, 그리고 가장 강력하게 객체지향을 강제하고 지원하는 언어이다"** 입니다.

Java는 현실 세계의 복잡함을 **클래스(Class)** 라는 설계도에 담아내고, **JVM**이라는 가상 머신 위에서 **객체(Object)** 들을 생동감 있게 움직이게 합니다.