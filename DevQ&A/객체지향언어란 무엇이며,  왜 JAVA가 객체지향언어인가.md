# 객체지향 프로그래밍(OOP)이란? 왜 자바는 객체지향 언어인가?

## 1. 개요 (Overview)
### 1.1 정의
**객체지향 프로그래밍(Object-Oriented Programming, OOP)**은 프로그램을 단순히 데이터와 처리 방법(로직)으로 나누는 것이 아니라, **'객체(Object)'라는 독립적인 단위**들의 모임으로 파악하고, 이 객체들이 서로 **메시지**를 주고받으며 데이터를 처리하는 소프트웨어 개발 패러다임입니다.

### 1.2 핵심 철학
> **"현실 세계를 프로그래밍으로 옮겨오다."**

자동차를 만들 때 바퀴, 엔진, 핸들 같은 부품(객체)을 먼저 만들고 조립하듯이, 소프트웨어도 부품(객체) 단위로 만들어 조립한다는 개념입니다.

---

## 2. 등장 배경: 절차지향의 한계
OOP가 왜 주류가 되었는지 알기 위해선 그 이전인 **절차지향(Procedural Programming)**과 비교해야 합니다.

| 구분     | 절차지향 (C언어 등)                                               | 객체지향 (Java, C++, Python)  |
| :----- | :--------------------------------------------------------- | :------------------------ |
| **중심** | **기능(함수)와 순서** 중심                                          | **데이터(객체)** 중심            |
| **접근** | "어떻게(How) 처리할 것인가?"                                        | "누가(Who) 처리할 것인가?"        |
| **단점** | 코드가 길어지면 유지보수가 어렵고, 데이터가 여기저기서 수정되어 추적이 힘듦(Spaghetti Code) | 설계가 어렵고 초기 개발 속도가 느릴 수 있음 |
|        |                                                            |                           |

![절차지향 vs 객체지향 비교](https://i.ibb.co/ccf8xKWB/vs.png)

---

## 3. 객체지향의 4대 특성 (The 4 Pillars of OOP)
자바가 강력한 이유는 이 4가지 특성을 언어 차원에서 완벽하게 지원하기 때문입니다.

### 3.1 캡슐화 (Encapsulation)
- **개념:** 데이터(필드)와 그 데이터를 처리하는 코드(메서드)를 하나로 묶고, 외부에서 함부로 접근하지 못하게 **정보를 은폐(Information Hiding)**하는 것.
- **자바 구현:** `private` 접근 제어자로 필드를 숨기고, `public`한 `getter/setter` 메서드로만 접근하게 함.
- **목적:** 데이터 무결성 보호.

### 3.2 상속 (Inheritance)
- **개념:** 부모 클래스의 속성과 기능을 자식 클래스가 물려받아 사용하는 것.
- **자바 구현:** `extends` 키워드 사용.
- **목적:** 코드의 재사용성 증가, 유지보수 용이.

### 3.3 다형성 (Polymorphism)
- **개념:** 하나의 객체나 메서드가 여러 가지 다른 형태를 가질 수 있는 성질.
- **자바 구현:**
    - **Overloading:** 이름은 같지만 매개변수가 다른 메서드.
    - **Overriding:** 부모의 메서드를 자식 입맛에 맞게 재정의.
- **목적:** 유연하고 변경에 강한 설계 가능 (인터페이스를 통한 느슨한 결합).

### 3.4 추상화 (Abstraction)
- **개념:** 불필요한 정보는 숨기고, 중요한 공통 특징(역할)만 뽑아내어 정의하는 것.
- **자바 구현:** `abstract class`, `interface`.
- **목적:** 구체적인 구현에 의존하지 않고 역할(인터페이스)에 의존하게 하여 유연성 확보.

---

## 4. 왜 'JAVA'가 객체지향 언어인가?
C++이나 Python도 객체지향을 지원하지만, 자바는 태생부터 **"객체가 아니면 아무것도 할 수 없는"** 구조입니다.

1.  **클래스 기반 (Class-Based):** 자바의 모든 코드는 반드시 `class` 안에 작성되어야 합니다. 심지어 메인 함수(`public static void main`)조차 클래스 내부에 존재해야 합니다. 전역 함수(Global Function)가 존재하지 않습니다.
2.  **강력한 캡슐화:** 접근 제어자(`private`, `protected`, `public`)를 통해 객체의 데이터 보호를 강제합니다.
3.  **단일 상속과 인터페이스:** 다중 상속의 모호함(Diamond Problem)을 없애기 위해 클래스는 단일 상속만 허용하되, `interface`를 통해 다형성을 극대화했습니다.

---

## 5. 예시 코드 (Example Code)
객체지향적으로 설계된 코드를 봅시다.

```java
// 1. 추상화 (역할 정의)
interface Drivable {
    void drive();
}

// 2. 캡슐화 & 상속 (구현)
class Car implements Drivable {
    private String model; // 캡슐화 (외부 접근 불가)

    public Car(String model) {
        this.model = model;
    }

    // 캡슐화 된 데이터에 접근하는 통로
    public String getModel() {
        return model;
    }

    @Override // 다형성 (오버라이딩)
    public void drive() {
        System.out.println(model + " 자동차가 부드럽게 주행합니다.");
    }
}

class Truck implements Drivable {
    @Override // 다형성 (같은 drive()지만 다르게 동작)
    public void drive() {
        System.out.println("트럭이 짐을 싣고 힘차게 주행합니다.");
    }
}

public class OOPExam {
    public static void main(String[] args) {
        // 3. 다형성 활용 (인터페이스 타입으로 받음)
        Drivable myCar = new Car("Tesla");
        Drivable myTruck = new Truck();

        // 같은 drive() 메시지를 보냈지만, 실제 객체에 따라 다르게 반응함
        myCar.drive();   // "Tesla 자동차가 부드럽게 주행합니다."
        myTruck.drive(); // "트럭이 짐을 싣고 힘차게 주행합니다."
    }
}
```

---

## 6. 장점과 단점 (Pros & Cons)

### 장점 (Pros)
- **코드 재사용성:** 상속을 통해 코드를 물려받아 중복을 줄일 수 있습니다.
- **유지보수성:** 수정이 필요한 부분(클래스)만 고치면 되므로 전체 시스템에 미치는 영향이 적습니다.
- **대형 프로젝트 적합:** 부품(모듈)화 되어 있어 여러 명의 개발자가 분담하여 개발하기 쉽습니다.

### 단점 (Cons)
- **개발 속도:** 설계 단계에서 객체 간의 관계를 고민하는 시간이 많이 듭니다.
- **실행 속도:** 절차지향 언어(C)에 비해 처리 속도가 상대적으로 느릴 수 있습니다. (객체 생성 및 메모리 관리 비용)
- **높은 러닝 커브:** 다형성, 인터페이스, 디자인 패턴 등 익혀야 할 이론이 많습니다.

---

## 7. 결론 (Conclusion)
자바가 객체지향 언어인 이유는 **"프로그램을 독립된 객체들의 협력으로 바라보고, 이를 언어 차원에서 강제하고 지원하기 때문"**입니다.

좋은 자바 개발자가 되기 위해서는 단순히 문법을 아는 것을 넘어, **"어떻게 하면 객체들이 서로 적절한 책임을 나누고 협력하게 만들 것인가(객체지향적 설계)"**를 끊임없이 고민해야 합니다. 이는 곧 **Spring Framework**와 같은 객체지향 프레임워크를 잘 다루는 기초가 됩니다.