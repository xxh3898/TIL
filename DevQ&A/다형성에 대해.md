# 다형성(Polymorphism): 객체지향의 유연함을 완성하다

## 1. 개요 (Overview)
### 1.1 정의
**다형성(Polymorphism)**이란 "여러 가지 형태를 가질 수 있는 능력"을 의미합니다.
프로그래밍적으로는 **하나의 참조 변수(인터페이스/부모 클래스)로 여러 타입의 객체(구현 클래스/자식 클래스)를 참조하고 동작시킬 수 있는 성질**을 말합니다.

### 1.2 핵심 슬로건
> **"One Interface, Multiple Implementations" (하나의 인터페이스, 다양한 구현)**

---

## 2. 다형성의 종류 (Types)
자바에서 다형성은 크게 두 가지 형태로 나타납니다.

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
| :--- | :--- | :--- |
| **별명** | **정적 다형성** (Compile-time) | **동적 다형성** (Run-time) |
| **정의** | 같은 이름의 메서드를 매개변수만 다르게 여러 개 정의 | 부모의 메서드를 자식이 재정의 |
| **결정 시점**| 컴파일 시점 | 실행(런타임) 시점 |
| **특징** | 편의성 제공 (메서드 이름 절약) | **진정한 의미의 다형성 (핵심)** |

---

## 3. 핵심 동작 원리 (Mechanism)

다형성이 가능한 이유는 **상속(Inheritance)**과 **업캐스팅(Upcasting)** 때문입니다.

![다형성 구조도](https://i.ibb.co/VcNsnS2d/image.png)

### 3.1 업캐스팅 (Upcasting)
부모 타입의 참조 변수로 자식 타입의 인스턴스를 참조하는 것입니다.
```java
// 부모 타입 = new 자식 타입();
Animal myDog = new Dog(); 
Animal myCat = new Cat();
```

### 3.2 동적 바인딩 (Dynamic Binding)
컴파일러는 `myDog`가 `Animal` 타입이므로 `Animal.cry()`를 호출한다고 생각하지만, **JVM은 실행 시점에 실제 객체가 `Dog`인 것을 확인하고 `Dog.cry()`를 실행**합니다. 이를 동적 바인딩이라고 합니다.

---

## 4. 왜 사용하는가? (Why & Importance)

1.  **유연성과 확장성 (Flexibility):**
    - 새로운 기능을 추가할 때 기존 코드를 변경하지 않아도 됩니다. (OCP: 개방-폐쇄 원칙)
2.  **결합도 감소 (Loose Coupling):**
    - 클라이언트 코드는 구체적인 클래스(`Dog`, `Cat`)를 몰라도 인터페이스(`Animal`)만 알면 됩니다.
3.  **코드 중복 제거:**
    - 여러 종류의 객체를 하나의 배열이나 리스트(`List<Animal>`)로 묶어서 관리할 수 있습니다.

---

## 5. 예시 코드 (Example)
다형성을 사용하지 않았을 때와 사용했을 때를 비교해 봅시다.

### 5.1 다형성이 없는 경우 (비효율적)
```java
class Driver {
    // 차 종류가 늘어날 때마다 메서드를 새로 만들어야 함
    public void drive(Bus bus) { bus.run(); }
    public void drive(Taxi taxi) { taxi.run(); }
}
```

### 5.2 다형성을 활용한 경우 (효율적)
`Bus`와 `Taxi`가 `Vehicle` 인터페이스를 구현하고 있다면:

```java
interface Vehicle {
    void run();
}

class Bus implements Vehicle {
    public void run() { System.out.println("버스가 달립니다."); }
}

class Taxi implements Vehicle {
    public void run() { System.out.println("택시가 달립니다."); }
}

class Driver {
    // 매개변수의 다형성!
    // 어떤 차(Vehicle 구현체)가 들어와도 이 코드 하나로 동작함.
    public void drive(Vehicle vehicle) {
        vehicle.run(); // 실제 들어온 객체의 run()이 실행됨
    }
}

public class Main {
    public static void main(String[] args) {
        Driver driver = new Driver();
        
        driver.drive(new Bus());  // "버스가 달립니다."
        driver.drive(new Taxi()); // "택시가 달립니다."
    }
}
```
**이점:** 나중에 `Truck`이 추가되어도 `Driver` 코드는 단 한 줄도 수정할 필요가 없습니다.

---

## 6. 사용 시 주의할 점 (Precautions)

### 6.1 부모에 없는 메서드 호출 불가
```java
Animal a = new Dog();
a.cry();  // 가능 (부모에 있음 + 오버라이딩)
a.bark(); // 불가능! (bark는 Dog에만 있는 메서드라면 컴파일 에러)
```
참조 변수가 부모 타입(`Animal`)이므로, 부모 클래스에 정의된 멤버만 보입니다. 자식만의 기능을 쓰려면 **다운캐스팅(Downcasting)**을 해야 합니다.

### 6.2 instanceof 연산자
다운캐스팅을 하기 전에, 실제 객체의 타입을 확인해야 안전합니다.
```java
if (a instanceof Dog) {
    Dog d = (Dog) a; // 강제 형변환 (Downcasting)
    d.bark();
}
```

---

## 7. 결론 (Conclusion)
다형성은 **"역할(Interface)과 구현(Implementation)을 분리"**하는 핵심 열쇠입니다.

스프링 프레임워크에서 `@Autowired`로 인터페이스를 주입받아 사용하는 것, DB를 Oracle에서 MySQL로 바꿔도 코드를 수정하지 않는 것 모두가 이 **다형성** 덕분입니다. 개발자로서 한 단계 성장하기 위해서는 다형성을 이용해 **'변하는 것'과 '변하지 않는 것'을 분리하는 설계 능력**이 필수적입니다.