# JVM 메모리 구조 (Runtime Data Areas): 변수는 어디에 저장될까?

## 1. 개요 (Overview)
### 1.1 정의
**JVM 메모리 구조**는 자바 프로그램이 실행될 때 OS로부터 할당받는 메모리 영역을 말하며, 기술적 용어로는 **Runtime Data Areas**라고 합니다.

### 1.2 핵심 구분
이 영역은 데이터의 특성과 생명주기에 따라 크게 **스레드 공유 영역(Shared)**과 **스레드 고유 영역(Per-Thread)**으로 나뉩니다.

![자바 런타임 데이터 영역 구조도](https://i.ibb.co/WWpTXrMz/image.png)

---

## 2. 왜 중요한가? (Why & Importance)
**면접관의 의도:**
"멀티 스레드 환경에서 데이터 동기화 문제가 발생하는 이유를 아는가?", "StackOverflowError와 OutOfMemoryError의 차이를 아는가?"를 묻기 위함입니다.

- **문제 해결:** 메모리 누수(Memory Leak)나 스레드 동기화(Synchronization) 문제를 해결하기 위한 기초 지식입니다.
- **성능 최적화:** 객체가 어디에 생성되고 언제 사라지는지 알아야 리소스를 효율적으로 쓸 수 있습니다.

---

## 3. 상세 구조 및 동작 (Architecture)

### 3.1 모든 스레드가 공유하는 영역 (GC의 대상)
이 영역에 있는 데이터는 모든 스레드에서 접근 가능하므로 **동기화 이슈**에 주의해야 합니다.

1.  **Method Area (메서드 영역)**
    - **저장 데이터:** 클래스 정보(.class), 전역 변수(static), 상수(final), 메서드 코드 자체.
    - **생명주기:** 프로그램 시작(JVM 구동) ~ 종료.
    - **특징:** 프로그램 로딩 시점에 딱 한 번 메모리에 올라갑니다.

2.  **Heap Area (힙 영역)**
    - **저장 데이터:** `new` 키워드로 생성된 **모든 객체와 배열**.
    - **생명주기:** 생성 시점 ~ GC에 의해 수거될 때까지.
    - **특징:** JVM 메모리 중 가장 큰 공간을 차지하며, GC(Garbage Collection)의 주요 활동 무대입니다.

### 3.2 각 스레드별로 생성되는 영역 (Thread-Safe)
스레드가 생성될 때 만들어지고, 스레드가 종료되면 함께 사라집니다. 다른 스레드는 접근할 수 없습니다.

3.  **Stack Area (스택 영역)**
    - **저장 데이터:** 메서드 호출 시 생성되는 **지역변수, 매개변수, 리턴 값**.
    - **동작 방식:** 메서드가 호출되면 프레임(Frame)이 쌓이고(Push), 메서드가 끝나면 제거(Pop)됩니다. (LIFO 구조)
    - **특징:** 기본형 타입(int, double 등) 변수는 값 자체가 저장되고, 참조형 변수는 힙 영역의 객체 주소값만 저장됩니다.

4.  **PC Register (PC 레지스터)**
    - **역할:** 현재 수행 중인 JVM 명령어의 주소를 가리킵니다. (CPU의 레지스터와 유사)
    - **이유:** 스레드가 번갈아 가며 실행될 때, 어디까지 실행했는지 기억해야 하기 때문입니다.

5.  **Native Method Stack**
    - **역할:** 자바가 아닌 C/C++로 작성된 네이티브 코드(JNI)를 실행할 때 사용하는 스택입니다.

---

## 4. 핵심 비교: Stack vs Heap (Comparison)

| 비교 항목 | Stack Area | Heap Area |
| :--- | :--- | :--- |
| **저장 대상** | 지역변수, 매개변수, 실행 프레임 | `new`로 생성된 객체, 배열 |
| **접근 범위** | 해당 스레드 내부 (Private) | 모든 스레드 공용 (Shared) |
| **생명 주기** | 메서드 호출 ~ 종료 | GC가 수거할 때까지 |
| **속도** | 빠름 (단순 포인터 이동) | 상대적으로 느림 (할당/해제 비용) |
| **에러** | `StackOverflowError` | `OutOfMemoryError` |

---

## 5. 예시 코드 (Example)
코드를 통해 변수가 어디에 저장되는지 추적해 봅시다.

```java
public class MemoryTest {
    // 1. Method Area (static 변수)
    static int sharedValue = 100; 

    public static void main(String[] args) {
        // 2. Stack Area (지역 변수 - 기본형)
        int score = 10; 

        // 3. Heap Area (객체 생성) & Stack Area (참조 변수 user)
        // 'new User()'는 Heap에 생성되고, 
        // 변수 'user'는 Stack에 생성되어 Heap의 주소를 가리킴.
        User user = new User("James"); 
        
        user.sayHello();
    }
}

class User {
    // 4. Heap Area (인스턴스 필드) - 객체 내부에 저장됨
    String name; 

    public User(String name) {
        this.name = name;
    }
    
    public void sayHello() {
        // 5. Stack Area (메서드 실행 프레임 생성)
        System.out.println("Hello " + name);
    }
}
```

---

## 6. 사용 시 주의할 점 (Precautions)

### 6.1 스레드 동기화 (Thread Safety)
Heap 영역의 객체(인스턴스 변수)를 여러 스레드가 동시에 수정하면 **Race Condition**이 발생합니다.
- **해결:** `synchronized` 키워드 등을 사용하여 동시 접근을 제어하거나, 불변 객체(Immutable)를 사용해야 합니다.

### 6.2 재귀 호출과 스택 오버플로우
재귀 함수가 종료 조건을 만나지 못하고 계속 호출되면 Stack 영역이 꽉 차서 `StackOverflowError`가 발생합니다.

### 6.3 메모리 누수
더 이상 쓰지 않는 객체를 Static 컬렉션 등에 계속 담아두면 Heap이 가득 차 `OutOfMemoryError`가 발생하여 서버가 다운됩니다.

---

## 7. 요약 및 결론 (Conclusion)
JVM 메모리 구조를 이해하는 것은 **"내 데이터가 언제, 어디서, 어떻게 관리되는가?"**를 아는 것입니다.

- **Stack:** 메서드의 작업대. 빠르고 임시적인 데이터.
- **Heap:** 창고. 크고 무겁고 공유되는 데이터.
- **Method Area:** 설계도 보관소. 공통 정보.

이 구조를 머릿속에 그리고 코딩을 한다면, 멀티 스레드 환경에서의 버그를 예방하고 더 효율적인 애플리케이션을 만들 수 있습니다.