## Topic (자바의 메모리 구조) 2025-11-26

- **주제:** JVM Runtime Data Area (자바 런타임 데이터 영역)의 상세 구조와 역할


### **Why (왜 사용하는가? 왜 중요한가?)**

> 이 개념이 실무, 설계, 면접에서 중요한 이유를 정리한다.

- **실무**: 메모리 누수(Memory Leak)나 `OutOfMemoryError`(OOM) 발생 시, 어느 영역(Heap vs Stack)의 문제인지 파악하고 디버깅하기 위해 필수적이다.

- **구조적 의미**: 데이터의 특성에 따라 '공유되는 영역(Heap, Method)'과 '스레드별 고유 영역(Stack 등)'을 분리하여 멀티스레드 환경의 안정성과 효율성을 제공한다.

- **면접 의도**: 변수의 생명주기(Lifecycle)와 스코프(Scope)를 정확히 이해하고 있는지, static과 instance 변수의 차이를 메모리 관점에서 설명할 수 있는지 확인한다.


### **Core Concept (핵심 개념 정리)**

> 단순한 정의가 아닌, 의미 + 구조 + 비교 + 조건 중심으로 작성한다.

| **요소**    | **내용**                                                                                                                                                                                                                                                                                                                                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **개념 정의** | JVM이 OS로부터 할당받은 메모리 공간으로, 자바 애플리케이션 실행 중에 데이터가 저장되는 영역.                                                                                                                                                                                                                                                                                                                        |
| **동작 방식** | 크게 5가지 영역으로 구분:<br><br>  <br><br>1. **Method Area**: 클래스 정보, static 변수 저장 (모든 스레드 공유)<br><br>  <br><br>2. **Heap**: `new`로 생성된 객체/배열 저장 (GC 대상, 모든 스레드 공유)<br><br>  <br><br>3. **Stack**: 메서드 호출 시 프레임 생성, 지역변수/매개변수 저장 (스레드별 독립)<br><br>  <br><br>4. **PC Register**: 현재 실행 중인 JVM 명령 주소 저장 (스레드별 독립)<br><br>  <br><br>5. **Native Method Stack**: 자바 외 언어(C/C++)로 된 코드 실행 공간 |
| **장점/단점** | **장점**: 스레드 간 공유 데이터와 독립 데이터를 명확히 분리하여 동시성 프로그래밍 지원<br><br>  <br><br>**단점**: 힙 영역 관리가 미흡하면 GC 오버헤드로 성능 저하 발생 가능                                                                                                                                                                                                                                                                |
| **예시/비교** | **Stack vs Heap**:<br><br><br>- **Stack**: LIFO 구조, 메서드 종료 시 자동 소멸, 빠름.<br><br><br>- **Heap**: 복잡한 구조, GC가 소멸 관장, 상대적으로 느림, 전역 접근 가능.                                                                                                                                                                                                                                          |

### **Interview Answer Version (면접 답변식 요약)**

> 30~40초 분량으로, **정의 → 쓰는 이유 → 핵심 효과/특징**순으로 말하듯 요약

"자바의 메모리 구조는 크게 스레드가 공유하는 영역과 고유 영역으로 나뉩니다. **공유 영역**에는 클래스 정보가 담긴 'Method Area'와 객체가 생성되는 'Heap'이 있으며, 이곳은 GC의 관리 대상입니다. 반면 **스레드 고유 영역**에는 메서드 호출 시 지역변수가 저장되는 'Stack'과 실행 주소를 담는 'PC Register'가 있습니다. 이 구조를 이해해야 **변수의 스코프**와 **메모리 효율성**을 고려한 코드를 작성할 수 있습니다."

### **Practical Tip (사용시 주의할 점 or 활용 예)**

> 실제로 어떻게 쓰이며, 잘못 쓰면 어떤 문제가 생기는지를 구체적인 예시로 작성헌다. 사용한 경험이 있다면 해당 코드를 기준으로 정리한다.

- **흔히 발생하는 에러 구분**:
    
    - `StackOverflowError`: 재귀 호출이 너무 깊어지거나 무한 루프에 빠져 스택 프레임이 꽉 찼을 때 발생. (탈출 조건 확인 필수)
    
    - `OutOfMemoryError (Java heap space)`: 힙에 객체가 너무 많아 더 이상 할당할 수 없을 때 발생.
    
- **String 생성 방식의 차이 (코드 예시)**:
	
``` Java
	String str1 = "Hello"; // String Constant Pool (Heap 내부)에 저장, 재사용됨 (메모리 효율적)
	   
	String str2 = new String("Hello"); // Heap에 매번 새로운 객체 생성 (메모리 낭비 가능성)
```
    
- **이걸 모르고 사용하면 생기는 문제**:
    
    - `static` 키워드를 남발하면 Method Area(혹은 Metaspace)에 영구적으로 남아 메모리 누수의 원인이 될 수 있음.
    
    - 지역 변수(Stack)에 저장해도 될 데이터를 굳이 멤버 변수(Heap)로 선언하여 불필요하게 객체 상태를 유지시키는 실수.


### 예상 꼬리 질문 정리

> 추가로 나올 수 있는 질문 3개 이상 생각해보기.

1. **자바 8 이후 PermGen 영역이 Metaspace로 변경되었는데, 가장 큰 차이점은 무엇인가요?** (메모리 관리 주체가 JVM에서 OS로 변경됨 등)

2. **멀티 스레드 환경에서 스택 영역은 스레드 안전(Thread-safe)한가요? 그 이유는 무엇인가요?** (다른 스레드가 접근할 수 없는 독립 공간이기 때문)

3. **Primitive Type(기본형)과 Reference Type(참조형)은 각각 메모리의 어느 영역에 저장되나요?** (기본형은 스택에 값 자체 저장, 참조형은 스택에 주소만 저장하고 실제 값은 힙에 저장)