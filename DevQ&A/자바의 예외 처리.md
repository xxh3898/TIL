# 자바의 예외 처리(Exception): 견고한 애플리케이션의 조건

## 1. 개요 (Overview)
### 1.1 정의
**예외(Exception)**란 프로그램 실행 중에 발생하는 예기치 않은 사건(Event)을 말합니다.
자바에서는 예외도 하나의 **객체**로 취급하며, 이를 적절히 처리하지 않으면 프로그램이 비정상적으로 종료됩니다.

### 1.2 예외 처리(Exception Handling)란?
예외가 발생했을 때 프로그램이 셧다운(Crash)되지 않고, 로그를 남기거나 대체 로직을 실행하여 **정상적인 실행 상태를 유지**하도록 만드는 기술입니다.

---

## 2. 예외 계층 구조 (Hierarchy)

자바의 예외는 모두 `java.lang.Throwable` 클래스를 상속받습니다. 크게 **Error**와 **Exception**으로 나뉩니다.

![자바 예외 계층 구조](https://i.ibb.co/1Gsw4fVh/image.png)

1.  **Error (에러):**
    - **시스템 레벨**의 심각한 문제입니다. (예: `OutOfMemoryError`, `StackOverflowError`)
    - 개발자가 코드에서 복구할 수 없는 수준이므로, 애플리케이션 단에서 `catch` 하려고 시도해서는 안 됩니다.
2.  **Exception (예외):**
    - **개발자**가 로직으로 제어할 수 있는 실수나 외적인 요인입니다.
    - 다시 두 가지로 나뉩니다: **Checked Exception** vs **Unchecked Exception**.

---

## 3. 핵심 비교: Checked vs Unchecked Exception

| 구분 | Checked Exception | Unchecked Exception |
| :--- | :--- | :--- |
| **상속 대상** | `Exception`을 상속 (RuntimeException 제외) | `RuntimeException`을 상속 |
| **확인 시점** | **컴파일 단계** (Compile Time) | **실행 단계** (Run Time) |
| **처리 여부** | **반드시 처리해야 함** (try-catch or throws) | 명시적 처리를 강제하지 않음 |
| **트랜잭션 처리** | 기본적으로 **Rollback 안 함** | 기본적으로 **Rollback 함** |
| **대표 예시** | `IOException`, `SQLException` | `NullPointerException`, `IndexOutOfBoundsException` |
| **발생 원인** | 외부 환경 (파일 없음, 네트워크 등) | 개발자의 로직 실수 |

---

## 4. 동작 원리 및 문법 (Mechanism)

### 4.1 기본 구조 (try-catch-finally)
```java
public void readFile() {
    try {
        // 1. 예외가 발생할 가능성이 있는 코드
        System.out.println("파일 읽기 시도...");
        throw new IOException("파일이 없습니다!"); // 강제 예외 발생
        
    } catch (IOException e) {
        // 2. 예외 발생 시 수행할 코드 (복구 로직)
        System.out.println("예외 처리: " + e.getMessage());
        
    } finally {
        // 3. 예외 발생 여부와 상관없이 무조건 실행 (리소스 해제 등)
        System.out.println("리소스 해제 완료");
    }
}
```

### 4.2 예외 던지기 (throws)
메서드 내부에서 직접 처리하지 않고, 이 메서드를 호출한 곳으로 **책임을 전가**할 때 사용합니다.
```java
// 호출한 쪽에서 try-catch를 해야 함
public void connect() throws SQLException {
    // DB 연결 로직
}
```

---

## 5. 자바 7 이후의 변화: Try-with-resources
과거에는 `finally` 블록에서 파일을 닫거나 DB 연결을 끊는(`close()`) 코드가 매우 지저분했습니다. 이를 개선하기 위해 **자동 리소스 관리** 기능이 도입되었습니다.

```java
// AutoCloseable 인터페이스를 구현한 객체만 사용 가능
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // 파일을 읽는 로직
    // try 블록이 끝나면 자동으로 fis.close()가 호출됨
} catch (IOException e) {
    e.printStackTrace();
}
```
**이점:** 코드가 간결해지고, 실수로 `close()`를 빼먹어 발생하는 리소스 누수(Memory Leak)를 방지합니다.

---

## 6. 사용 시 주의할 점 & Best Practice

### 6.1 예외를 삼키지 마라 (Swallowing Exceptions)
가장 나쁜 습관입니다.
```java
try {
    ...
} catch (Exception e) {
    // 아무것도 안 함 (최악)
}
```
이렇게 하면 어디서 에러가 났는지 알 수 없어 디버깅이 불가능해집니다. 최소한 `e.printStackTrace()`나 로그(`log.error`)는 남겨야 합니다.

### 6.2 구체적인 예외를 잡아라
`catch (Exception e)` 처럼 뭉뚱그려 잡기보다, `catch (NullPointerException e)` 처럼 구체적으로 잡아야 정확한 원인 파악과 처리가 가능합니다.

### 6.3 커스텀 예외 활용 (Custom Exception)
비즈니스 로직에 맞는 명확한 예외가 필요할 땐 직접 만들어 씁니다.
- 예: `AccountNotFoundException` (계좌를 찾을 수 없음)
- **장점:** 예외 이름만으로도 어떤 상황인지 명확히 알 수 있어 유지보수성이 높아집니다.

---

## 7. 사용하지 않을 땐? (Alternatives)
예외 처리는 비쌉니다(Stack Trace 생성 비용). 예외를 로직 제어용으로 쓰지 마세요.

1.  **Optional (Java 8+):**
    - `NullPointerException`을 피하기 위해 null 체크용 `if`문이나 try-catch 대신 `Optional`을 사용하여 우아하게 처리합니다.
2.  **Result Object Pattern:**
    - 예외를 던지는 대신, 성공/실패 여부와 메시지를 담은 객체(Result DTO)를 리턴하여 호출자가 판단하게 합니다.

---

## 8. 결론 (Conclusion)
자바의 예외 처리는 프로그램의 **안전벨트**입니다.

초보 개발자는 "에러가 안 나게 하는 것"에만 집중하지만, 시니어 개발자는 **"에러가 났을 때 시스템이 어떻게 행동해야 하는가"**를 설계합니다. Checked와 Unchecked의 차이를 명확히 이해하고, `try-with-resources`와 같은 모던 자바 문법을 활용하여 견고한 코드를 작성해 보세요.