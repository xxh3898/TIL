# 제네릭(Generics): 타입 안정성을 지키는 수호자

## 1. 개요 (Overview)
### 1.1 정의
**제네릭(Generics)**은 클래스나 메서드 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법입니다.
코드 작성 시에는 타입을 확정하지 않고 **파라미터처럼(`<T>`)** 비워두었다가, 실제로 코드를 사용할 때 구체적인 타입(String, Integer 등)을 지정합니다.

### 1.2 비유
> **"음료수 자판기"**

자판기(클래스)를 공장에서 만들 때는 안에 콜라가 들어갈지 사이다가 들어갈지 모릅니다.
설치하는 시점(객체 생성)에 "이건 콜라 자판기야"라고 라벨(`<Cola>`)을 붙이는 것과 같습니다.

---

## 2. 왜 사용하는가? (Why & Importance)
제네릭이 없던 시절(Java 1.4 이전)에는 모든 객체를 `Object` 타입으로 받았고, 꺼낼 때마다 형변환(Casting)을 해야 했습니다.

1.  **타입 안정성 (Type Safety):** 컴파일 타임에 강력한 타입 체크를 수행하여, 런타임 에러(`ClassCastException`)를 미연에 방지합니다.
2.  **형변환 생략:** 코드가 간결해지고 가독성이 좋아집니다.

---

## 3. 동작 원리: 타입 소거 (Type Erasure)
자바의 제네릭은 **컴파일 시점에만 존재하고 런타임에는 사라집니다.** 이를 **타입 소거(Type Erasure)**라고 합니다.

- **Compile Time:** `List<String>`으로 타입을 체크합니다.
- **Run Time:** 제네릭 정보가 지워지고 `List`(Raw Type) 혹은 `List<Object>`로 변환되어 동작합니다.
- **이유:** 제네릭이 없던 예전 버전(Java 1.4 이하)의 라이브러리와 호환성을 유지하기 위해서입니다.

![자바 제네릭 타입 소거 과정](https://i.ibb.co/3mgsKBJK/image.png)

---

## 4. 사용 방법 및 문법 (Syntax)

### 4.1 기본 문법
자주 사용하는 타입 변수 약어입니다. (관례일 뿐 강제는 아님)
- **`<T>`**: Type
- **`<E>`**: Element (주로 컬렉션에서 사용)
- **`<K, V>`**: Key, Value
- **`<N>`**: Number

### 4.2 클래스 제네릭
```java
// 1. 제네릭 클래스 선언
class Box<T> {
    private T item;
    
    public void set(T item) { this.item = item; }
    public T get() { return item; }
}

// 2. 사용
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
// stringBox.set(100); // 컴파일 에러! (타입 안정성 확보)
```

---

## 5. 와일드카드와 제한 (Wildcards & Bounded Types)
제네릭의 유연성을 높이기 위해 사용합니다.

1.  **`<? extends T>` (상한 제한):** T와 그 자식들만 가능. (꺼내기만 가능, 읽기 전용)
2.  **`<? super T>` (하한 제한):** T와 그 조상들만 가능. (저장하기 가능)
3.  **`<?>` (와일드카드):** 모든 타입 가능 (`<? extends Object>`와 동일)

```java
// 예: Number의 자식들(Integer, Double 등)만 받을 수 있는 리스트
public void printNumberList(List<? extends Number> list) {
    for (Number n : list) {
        System.out.println(n);
    }
}
```

---

## 6. 장점과 단점 (Pros & Cons)

### 장점 (Pros)
- **강력한 타입 체크:** 에러를 실행 전(컴파일 타임)에 잡을 수 있어 프로그램이 안전해집니다.
- **재사용성:** 하나의 클래스로 여러 타입을 처리할 수 있습니다. (예: `ArrayList<Integer>`, `ArrayList<String>`)

### 단점 (Cons)
- **복잡성:** 와일드카드나 타입 범위 제한(`extends`, `super`)이 섞이면 코드를 읽기 어려워질 수 있습니다.
- **배열 생성 불가:** `new T[10]` 같은 배열 생성은 불가능합니다. (타입 소거 때문에 메모리 크기를 알 수 없어서)

---

## 7. 비교: 배열 vs 제네릭 (Array vs Generic)

| 구분 | 배열 (Array) | 제네릭 (List 등) |
| :--- | :--- | :--- |
| **타입 체크** | 런타임 (공변성) | 컴파일 타임 (불공변성) |
| **타입 변경** | `Object[]`에 `String` 넣어도 컴파일 됨 | `List<Object>`에 `List<String>` 대입 불가 |
| **안전성** | 상대적으로 낮음 | **높음** |

---

## 8. 사용 시 주의할 점 (Precautions)
### 8.1 Raw Type 사용 금지
제네릭 타입을 적지 않고 사용하는 것을 Raw Type이라고 합니다.
```java
List list = new ArrayList(); // 절대 금지!
list.add("String");
list.add(100); // 런타임 에러의 주범
```
이렇게 쓰면 제네릭의 장점이 모두 사라지므로, IDE 경고를 무시하지 말고 반드시 `<Type>`을 명시해야 합니다.

### 8.2 Static 멤버 사용 불가
제네릭 타입 `T`는 인스턴스 변수로 간주되므로, 모든 객체가 공유하는 `static` 멤버에는 사용할 수 없습니다. (static 메서드에는 제네릭 메서드로 별도 선언하면 사용 가능)

---

## 9. 결론 (Conclusion)
제네릭은 자바를 **'안전한 언어'**로 만들어주는 일등 공신입니다.

처음엔 `<T>`가 낯설 수 있지만, 이를 잘 활용하면 **중복 코드를 획기적으로 줄이고**, **런타임 버그 없는 견고한 애플리케이션**을 설계할 수 있습니다. 라이브러리나 프레임워크 소스를 분석할 때도 필수적인 지식이므로 와일드카드 패턴까지 꼭 익혀두세요.