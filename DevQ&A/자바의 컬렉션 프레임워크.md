# 배열만 쓰면 안 될까? 컬렉션 프레임워크(Collections Framework)

자바를 공부하다 보면 배열(Array) 다음으로 반드시 마주치는 **컬렉션 프레임워크(Collections Framework)**
"그냥 배열 쓰면 되는 거 아냐?"라고 생각할 수 있지만, 실무에서 배열만 고집했다가는 야근을 피할 수 없습니다.

오늘은 **왜 배열 대신 컬렉션을 써야 하는지**, 그리고 **상황별로 어떤 컬렉션을 골라 써야 하는지** 정리해 보겠습니다.

---

## 1. 왜 컬렉션 프레임워크인가? 

### 우리가 알던 배열(Array)의 치명적인 단점
자바 기초 때 배우는 배열은 선언이 쉽고 빠르지만, 유연하지 못하다는 치명적인 단점이 있습니다.

**① 크기가 고정되어 있다 (Fixed Size)**
처음에 `new int[10]`으로 만들었는데 데이터가 11개가 들어오면?
-> 더 큰 배열을 새로 만들고, 기존 데이터를 **일일이 복사**해야 합니다. (굉장히 비효율)

**② 데이터 삭제가 불편하다**
배열 중간에 있는 데이터를 삭제하면 그 자리는 `null` 혹은 비어있는 상태가 됩니다.
-> 뒤에 있는 데이터들을 앞으로 한 칸씩 **직접 당겨오는 로직**을 짜야 합니다.

```java
// 배열의 불편한 점 예시: 중간 데이터 삭제 시 구멍이 뻥 뚫림
String[] arr = {"A", "B", "C", "D"};
arr[1] = null; // "B" 삭제
// 결과: ["A", null, "C", "D"] -> 중간에 구멍이 생김, 뒤에 걸 당겨와야 함
```

### 해결사: 컬렉션 프레임워크
이러한 배열의 한계를 극복하기 위해 자바는 **자료구조(Data Structure)** 를 클래스로 구현해 놓았습니다. 이것이 바로 컬렉션 프레임워크입니다.

* **크기 자동 조절:** 데이터가 늘어나면 알아서 저장 공간을 늘립니다.
* **편리한 기능:** 데이터 추가, 삭제, 검색, 정렬이 메서드 하나로 끝납니다.

---

## 2. 컬렉션 프레임워크의 핵심 구조

컬렉션 프레임워크는 크게 두 가지 뿌리로 나뉩니다.
1.  **Collection 인터페이스:** 객체들을 한곳에 모아두는 방식 (List, Set)
2.  **Map 인터페이스:** 키(Key)와 값(Value) 쌍으로 관리하는 방식
![자바 컬렉션 프레임워크 구조도](https://hyuntaekhong.github.io/assets/images/java/java-basic25/collection01.png)

### [한 눈에 보는 3대장 요약]
| 종류 | 인터페이스 | 특징 | 비유 |
| :--- | :--- | :--- | :--- |
| **List** | `List` | **순서 O, 중복 O** | 맛집 대기열 (순서대로, 같은 사람 또 줄 서기 가능) |
| **Set** | `Set` | **순서 X, 중복 X** | 로또 번호 (순서 상관없음, 중복 불가) |
| **Map** | `Map` | **Key-Value 쌍** | 지하철 물품 보관함 (사물함 번호(Key)는 유일해야 함) |

---

## 3. 상세 분석: 상황별 골라 쓰기

### 1. List (리스트) - "순서가 중요할 때"
가장 배열과 비슷하며, 데이터를 넣는 순서대로 저장됩니다.

![리스트](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTzwfrlSCn3L8Zcge0NU0MD_sbDvGv0ubKRRg&s)

* **`ArrayList`**
    * **특징:** 내부적으로 배열을 이용합니다. 데이터를 찾을 때(조회) 속도가 가장 빠릅니다.
    * **단점:** 중간에 데이터를 끼워 넣거나 빼는 건 느립니다.
    * **용도:** **대부분의 경우 그냥 이거 쓰면 됩니다.** (웹 게시판, 목록 조회 등)

``` java
// 선언 (제네릭으로 타입 지정)
List<String> list = new ArrayList<>();

// 1. 데이터 추가
list.add("Java");
list.add("Spring");
list.add("Java"); // 중복 허용: "Java"가 두 번 들어감

// 2. 데이터 조회 (0번부터 시작)
String item = list.get(1); // "Spring" 반환

// 3. 데이터 삭제
list.remove(0); // 첫 번째 "Java" 삭제
```

* **`LinkedList`**
    * **특징:** 데이터들이 줄줄이 비엔나처럼 연결되어 있습니다. 중간 삽입/삭제가 엄청 빠릅니다.
    * **단점:** 데이터를 찾는 속도는 느립니다.

### 2. Set (셋) - "중복을 제거해야 할 때"
순서가 뒤죽박죽이라도 상관없고, **유니크(Unique)한 데이터**만 필요할 때 씁니다.

* **`HashSet`**
    * **특징:** 가장 빠릅니다. 순서를 전혀 예측할 수 없습니다.
    * **용도:** 중복 아이디 제거, 태그 관리.

``` java
Set<String> set = new HashSet<>();

// 1. 데이터 추가
set.add("Apple");
set.add("Banana");
set.add("Apple"); // 중복 발생 -> 저장되지 않고 무시됨

// 2. 크기 확인
System.out.println(set.size()); // 2 출력 (Apple은 하나만 저장됨)

// 3. 데이터 존재 여부 확인 (검색)
if (set.contains("Banana")) {
    System.out.println("바나나가 목록에 있습니다.");
}
```

* **`TreeSet`**
    * **특징:** 저장하면서 자동으로 **정렬(오름차순)** 을 해줍니다.
    * **용도:** 범위 검색이나 정렬된 데이터가 필요할 때.

### 3. Map (맵) - "데이터를 빨리 찾아야 할 때"
`Key`를 알면 `Value`를 바로 찾을 수 있습니다. 검색 속도가 자료구조 중 가장 빠릅니다.

* **`HashMap`**
    * **특징:** 가장 많이 씁니다. 순서는 없습니다.
    * **용도:** JSON 데이터 파싱, 설정 파일 읽기, 메모리 캐시.

``` java
Map<String, Integer> map = new HashMap<>();

// 1. 데이터 저장 (Key, Value)
map.put("userA", 90);
map.put("userB", 100);
map.put("userA", 80); // Key 중복 -> 기존 90이 사라지고 80으로 업데이트됨

// 2. 데이터 조회 (Key를 주면 Value를 줌)
int score = map.get("userA"); // 80 반환

// 3. 데이터 삭제
map.remove("userB"); // Key가 "userB"인 데이터 삭제
```

* **`TreeMap`**
    * **특징:** Key를 기준으로 정렬되어 저장됩니다.

---

## 4. 요약 및 가이드

### 배열 vs 컬렉션 비교

![비교](https://lh3.googleusercontent.com/rd-gg-dl/ABS2GSnV29sfK62ECDJuvu_ZCPjZ26fMoTmIQo2sszZOca_FgRc3Wp2ADXns2iNyM94f_3WimOUea2PDVw16Zu79lcFzmpD5P1VG-VEEHGHrJEXdue4d81CheDpsveLjSoKMTsoEe4EsyoVi6nO2xt6GVMJ4zuFl3CJ1g7yQfi3DQJeeQqpTc4Jmcy7Kq6O12sRZPsZ10SXXdvE3FspHB7HxsEnyLQ-t9QIdv6D9KIweOtQLSL3Dm65eEMpvBZeSXgIQboY6MwZTbvEy8CfAjMIXhZRgPVpuRoSct6_rrsRTyOTw1REzKW9ta81flmpHJ4VqWkg8YkvlUVX2fv_7Idt01AYc27hCV5rVaceRJhiTAt6zSGmOUgeGNO2nFMBQaysIdDbrVXWgPh3hyBOpobli6QxCiKyYJq-40Ch2FbPqPYPOK3Rmmtl0EQNLRiF33p64nPIAUs--0geE633GxEwBuO5qsDn1cZLhxshKMee24_MORSmG3DWGuM3YnZL5MNLOXlR1py5GmbHfuZE13uyh1SpRqHZjUnwZ0N-u9zFd9jbazEpgyHMTFj5H-eYmGj4QH1i73M3aZxpNdxMn-C4u5Xms05LDFoWhEeSty45oYnz_7MMz37NXeIx0HWRP0oZkgqp26WhAvta7-RzYId1wikauo0k_u-4WwA18RxfjJNSxyVfj_fyQ3ZOFZucQmzqZD7c6mccw4WLcJYtNy3Kwpqw_uYP3uC0fdIrZzVNRVz2fjfylYzXbNn5XdpXqULobrRQxjX01u3qu7U3oe-bVO2s-jsFZmesvq_zjRsnWEopFnTvmfBgahLZXakZDf_T7zQYZJYS0L6J95JnUizgcK7edHfUhmMRpvbghbvMs-rauh7pjjFHvbi5p8OvWXEO1XdtLM0KttbkCjrDHh4NJrqXw5PjWkmTjCXgj-XivSKc_-cF5xT6G52AHBCz6FhchMxBQ5SSMfUYXqE8euO4lC3jxMXWGAkidg75AU8VjwhSURey82RWdLHDZqKpv7AQNSYHfz3K91MuvySagDrKoVU7OYYxpMKt111RUqC9OOqZqrvAcmbWWhYd3MY0Lv7Zy75EghQy9yyCDoCD31ZqfpfV5rOXCBrE0yMsRhcEVIOYfXtnFRVuUNGZbfSgaGWG0JEb5d5IKAAouDArTINtusD3GUGdmA_boPf4zZUYc1gzorcgiuNJN-80=s1024-rj)

| 비교 항목 | 배열 (Array) | 컬렉션 (Collection) |
| :--- | :--- | :--- |
| **크기** | 고정 (변경 불가) | 가변 (자동 증가) |
| **속도** | 단순 조회는 가장 빠름 | 기능이 많아 미세하게 느릴 수 있음 |
| **기본 타입** | 가능 (`int`, `double`) | 불가능 (Wrapper 클래스 `Integer` 등 사용 필수) |

### 그래서 뭘 써야 할까?
고민될 때는 아래 순서대로 선택하세요.

1.  데이터 개수를 모르겠고, 그냥 무난하게 저장하고 싶다? -> **`ArrayList`**
2.  중복된 데이터를 없애버리고 싶다? -> **`HashSet`**
3.  아이디로 회원 정보를 찾는 것처럼, 매칭되는 데이터가 필요하다? -> **`HashMap`**

---

### 마무리
배열의 경직된 구조에서 벗어나 컬렉션 프레임워크를 자유자재로 다루는 것은 자바 개발자의 필수 역량입니다. 처음에는 `ArrayList`와 `HashMap`만 확실히 익혀도 실무의 90%는 커버할 수 있습니다.