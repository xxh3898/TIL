# 📅 2025-11-27 (목) 데일리 회고록
**🏷️ Tags:** #React #Hooks #useState #useEffect #FunctionalComponent #11월

---

## ✅ To-Do List (Daily Routine)
- [x] 🐢 알고리즘 1문제 풀기 (백준/프로그래머스)
- [x] 🏫 수업 내용 복습 & 내 언어로 정리하기
- [x] 🏗️ 실습 코드 리팩토링 (클래스형 -> 함수형 변환)
- [ ] 📚 자격증/CS 공부 (30분 이상)
- [x] 🌱 1일 1커밋 (GitHub 잔디 심기)

---

## 📚 학습 내용
> 오늘 공부하면서 새롭게 배운 내용이나 정리한 개념

- **React Hooks**
    - 기존 클래스형 컴포넌트에서만 가능했던 상태(State) 관리와 생명주기(Lifecycle) 기능을 함수형 컴포넌트에서도 사용할 수 있게 해주는 기능이다. (v16.8 도입)
    - `use`로 시작하는 함수들을 의미한다.

- **useState**
    - 함수형 컴포넌트에서 상태를 관리하는 Hook.
    - `const [state, setState] = useState(초기값)` 형태로 구조 분해 할당하여 사용한다.
    - **비동기 업데이트**: `setState`는 즉시 값을 바꾸지 않고 예약을 걸어둔 뒤 리렌더링 시점에 일괄 처리(Batching)한다.
    - **함수형 업데이트**: 이전 상태값에 의존하여 값을 변경할 때는 `setState(prev => prev + 1)`처럼 콜백 함수를 사용하는 것이 안전하다.

- **useEffect**
    - 클래스형 컴포넌트의 생명주기 메서드(`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`)를 하나로 통합한 Hook.
    - **의존성 배열(Dependency Array)**에 따라 실행 시점이 달라진다.
        - `[]` (빈 배열): 마운트 시 1회 실행 (API 호출 등).
        - `[state]`: 해당 `state`가 변경될 때마다 실행.
        - `없음`: 모든 렌더링마다 실행 (권장하지 않음).
    - **Cleanup 함수**: `useEffect` 내부에서 `return` 하는 함수는 컴포넌트가 언마운트되거나 업데이트되기 직전에 실행되어 뒷정리 작업을 담당한다.

- **상태 끌어올리기 (Lifting State Up)**
    - 형제 컴포넌트 간에 데이터를 주고받아야 할 때, 부모 컴포넌트로 상태를 올리고 Props로 내려주는 패턴을 실습했다. (`LandingPage` -> `Toolbar`, `Grade`)

---

## 🧑🏻‍💻 코드 예제
> 수업 시간에 작성한 핵심 코드나 직접 변형한 코드

```jsx
// 1. useState의 함수형 업데이트 (UseStateTest.jsx)
const [num, setNum] = useState(0);

const onClickMinus = () => {
    // 이전 상태값을 확실하게 보장받기 위해 콜백 함수 사용
    setNum((prevNum) => prevNum - 1);
}
```

```jsx
// 2. useEffect의 다양한 사용법 (UesEffectTest.jsx)
useEffect(() => {
    console.log("마운트 시 1회만 실행");
}, []);

useEffect(() => {
    console.log("name이 변경될 때마다 실행");
}, [name]);

// Cleanup 함수 (componentWillUnmount 역할)
useEffect(() => {
    return () => {
        console.log("컴포넌트가 사라지거나 업데이트 되기 직전 실행");
    }
}, [num]);
```

```jsx
// 3. 상태 끌어올리기 (LandingPage.jsx)
const LandingPage = () => {
    const [isLogin, setIsLogin] = useState(false); // 부모에 상태 정의

    return (
        <div>
            {/* 자식에게 상태와 변경 함수를 전달 */}
            <Toolbar isLogin={isLogin} onClickLogin={() => setIsLogin(true)} />
            <Grade isLogin={isLogin} />
        </div>
    )
}
```

---

## 💣 Trouble Shooting
> 발생한 문제와 해결책

- **문제**: `setState`를 호출한 직후에 `console.log`로 값을 찍어봤는데, 변경된 값이 아니라 이전 값이 출력됨.
- **원인**: React의 상태 업데이트는 성능 최적화를 위해 **비동기(Asynchronous)** 로 처리되기 때문이다. 코드가 실행되는 시점에는 아직 상태 변경이 반영되지 않은 상태다.
- **해결**: 변경된 값을 확인하거나 로직을 수행하려면 `useEffect`의 의존성 배열에 해당 state를 넣어 감지하거나, `setState`의 콜백 함수 내부에서 처리해야 함을 이해했다.

---
## 🌟 잘한 점
> 오늘 하루 스스로 칭찬할 만한 점

- 어제 배운 클래스형 컴포넌트의 복잡한 생명주기 메서드들이 `useEffect` 하나로 깔끔하게 정리되는 과정을 코드로 직접 비교하며 이해한 점.
- `LandingPage` 예제를 통해 데이터의 흐름(단방향)을 파악하고 상태 끌어올리기를 직접 구현해본 것.

---

## ⚠️ 아쉬운 점
> 부족했던 점

- `useEffect`를 잘못 사용하면 무한 루프에 빠질 수 있다는 이야기를 들었는데, 아직 복잡한 의존성 배열 관리는 조금 헷갈린다.

---

## 🤔 내일 시도할 점
> 내일 시도하고 싶은 부분

- `useRef`를 사용하여 불필요한 리렌더링 없이 DOM 요소에 접근하는 방법을 배워보고 싶다. (스크롤 이동이나 포커스 주기 등)

---

## 💬 한줄평
> 오늘 하루를 한 문장으로 정리

> "Hooks 덕분에 코드가 훨씬 간결해졌다."