# 📅 2025-12-03 (수) 데일리 회고록
**🏷️ Tags:** #React #JS #Zustand #StateManagement #12월

---

## ✅ To-Do List (Daily Routine)
- [x] 🐢 알고리즘 1문제 풀기 (백준/프로그래머스)
- [x] 🏫 수업 내용 복습 & 내 언어로 정리하기
- [x] 🏗️ 실습 코드 리팩토링 (Context API -> Zustand 변환)
- [ ] 📚 자격증/CS 공부 (30분 이상)
- [x] 🌱 1일 1커밋 (GitHub 잔디 심기)

---

## 📚 학습 내용
> 오늘 공부하면서 새롭게 배운 내용이나 정리한 개념

- **Zustand (상태 관리 라이브러리)**
    - Redux나 Context API에 비해 보일러플레이트 코드가 매우 적고 사용하기 쉬운 상태 관리 라이브러리.
    - `create` 함수를 사용하여 스토어(Store)를 생성하고, 컴포넌트에서 훅(Hook)처럼 가져다 쓸 수 있다.

- **Store 생성과 상태 업데이트**
    - `set`: 상태를 변경할 때 사용한다. 불변성을 유지하며 상태를 병합(merge)해준다.
        - `set((state) => ({ count: state.count + 1 }))` 처럼 이전 상태를 인자로 받아 업데이트할 수 있다.
    - `get`: 스토어 내부에서 현재 상태 값을 조회할 때 사용한다.
        - `get().count` 처럼 액션 함수 내부에서 다른 상태 값을 참조해야 할 때 유용하다.

- **파생 상태와 로직 분리**
    - 컴포넌트 내부에 있던 복잡한 필터링 로직(`getFilteredTodos`)을 스토어 내부로 옮겨, UI 컴포넌트는 단순히 데이터를 받아 렌더링만 하도록 구조를 개선했다.

---

## 🧑🏻‍💻 코드 예제
> 수업 시간에 작성한 핵심 코드나 직접 변형한 코드

```javascript
// 1. Zustand 스토어 생성 (Counter)
import { create } from "zustand";

const useCounterStore = create((set, get) => ({
    count: 0,
    // set의 콜백으로 최신 state를 받아 업데이트 (불변성 유지)
    increase: () => set((state) => ({ count: state.count + 1 })),
    // get()을 통해 현재 상태 조회 가능
    decrease: () => set({ count: get().count - 1 }),
    reset: () => set({ count: 0 }),
}));

export default useCounterStore;
```

```javascript
// 2. 스토어 내부에서 필터링 로직 처리 (Todo)
getFilteredTodos: () => {
    const { todos, filter } = get(); // 현재 상태 가져오기

    return todos.filter(todo => {
        switch(filter){
            case "active": return !todo.completed;
            case "completed": return todo.completed;
            default: return true;
        }
    });
}
```

```jsx
// 3. 컴포넌트에서 사용 (Selector 패턴)
const CounterDisplay = () => {
    // 필요한 상태만 구조분해 할당으로 가져옴
    const { count } = useCounterStore();
    
    return <div>현재 카운트 : {count}</div>
}
```

---

## 💣 Trouble Shooting
> 발생한 문제와 해결책

- **문제**: 투두 리스트에서 필터링 기능을 구현할 때, `filter` 상태값에 따라 원본 배열(`todos`)을 직접 수정해야 하는지 헷갈림.
- **해결**: 원본 데이터(`todos`)는 유지하고, 이를 가공해서 반환하는 `getFilteredTodos` 함수를 스토어 내부에 만들어 뷰(View)에서 호출하는 방식으로 해결함. 이를 통해 데이터의 불변성을 지키면서 보여지는 목록만 변경할 수 있었음.

---
## 🌟 잘한 점
> 오늘 하루 스스로 칭찬할 만한 점

- Context API로 작성했던 전역 상태 관리를 Zustand로 리팩토링하면서 두 기술의 차이점과 장단점(특히 코드량 감소)을 명확하게 체감한 점.
- `CounterContoler`와 `CounterDisplay` 처럼 상태를 변경하는 컴포넌트와 보여주는 컴포넌트를 분리하여 설계한 점.

---

## ⚠️ 아쉬운 점
> 부족했던 점

- Zustand의 `persist` 미들웨어를 아직 사용해보지 않아서, 새로고침 시 데이터가 초기화되는 점이 아쉽다. 내일은 로컬 스토리지 연동을 해봐야겠다.

---

## 🤔 내일 시도할 점
> 내일 시도하고 싶은 부분

- Zustand 미들웨어(Middleware) 학습하기 (Persist, Devtools).

---

## 💬 한줄평
> 오늘 하루를 한 문장으로 정리

> "Context API는 provider 안에서만 사용할 수 있었지만, Zustand를 사용하면 전역에서 사용이 가능하다."