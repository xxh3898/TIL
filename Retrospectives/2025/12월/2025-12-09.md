# 📅 2025-12-09 (화) 데일리 회고록
**🏷️ Tags:** #Spring #Rest_API #H2_Database #12월

---

## ✅ To-Do List (Daily Routine)
- [x] 🐢 알고리즘 1문제 풀기 (백준/프로그래머스)
- [x] 🏫 수업 내용 복습 & 내 언어로 정리하기
- [x] 🏗️ 실습 코드 리팩토링 (복사 붙여넣기 ❌)
- [x] 📚 자격증/CS 공부 (30분 이상)
- [x] 🌱 1일 1커밋 (GitHub 잔디 심기)

---

## 📚 학습 내용
> 오늘 공부하면서 새롭게 배운 내용이나 정리한 개념

### 1. H2 Database
Java로 작성된 가볍고 빠른 **인메모리(In-Memory) 관계형 데이터베이스**. 주로 **개발, 테스트, 데모 환경**에서 사용된다.

#### 📌 주요 특징
| 항목 | 설명 |
| :--- | :--- |
| **경량** | 별도 설치 없이 실행 가능 (파일 또는 메모리 기반) |
| **속도** | 메모리에서 작동하므로 읽기/쓰기 성능이 우수함 |
| **웹 콘솔** | 브라우저를 통해 테이블 확인 및 SQL 실행 가능 |
| **SQL 호환** | 표준 SQL 문법 대부분 지원 (Oracle 호환 모드 제공) |

#### ⚙️ Spring Boot 설정
스프링 부트에서는 의존성 추가만으로 바로 사용 가능:
`dependencies { runtimeOnly 'com.h2database:h2' }`

**application.yml 설정 예시**
```yaml
spring:
  datasource:
    hikari:
      url: jdbc:h2:tcp://localhost/~/test  # 또는 jdbc:h2:mem:testdb
      driver-class-name: org.h2.Driver
      username: sa
      password:
  h2:
    console:
      enabled: true
      path: /h2-console
```

**설정값 상세**

| 항목 | 설명 |
| :--- | :--- |
| `jdbc:h2:mem:testdb` | 인메모리 모드로 동작 (애플리케이션 종료 시 데이터 초기화됨) |
| `ddl-auto: create` | 애플리케이션 실행 시 엔티티를 보고 테이블 자동 생성 |
| `h2.console.enabled` | 브라우저로 DB 웹 콘솔 접속 허용 (`true`) |
| `path: /h2-console` | 접속 경로 지정 (기본값: `/h2-console`) |

---

### 2. RESTful API
**REpresentational State Transfer**의 약자로, 리소스(자원)를 URI에 명확한 규칙으로 표현하고 HTTP 메서드를 통해 CRUD 작업을 수행하도록 설계된 **API 아키텍처 스타일**.

#### 🏛️ REST의 6가지 아키텍처 원칙
| 원칙                    | 설명                                     | 이점                    |
| :-------------------- | :------------------------------------- | :-------------------- |
| **Client-Server**     | UI와 데이터 저장을 분리하여 역할 독립성 유지             | 개발 생산성 증가, 유지보수 용이    |
| **Stateless**         | 요청 간 클라이언트의 상태(Context)를 서버에 저장하지 않음   | 서버 확장성 극대화, 장애 시 안정적  |
| **Cacheable**         | 응답의 캐시 가능 여부를 명시                       | 네트워크 비용 감소, 응답 속도 향상  |
| **Layered System**    | 로드 밸런서, 프록시 등 중간 계층 서버 구성 가능           | 보안 강화, 트래픽 분산, 확장성 증대 |
| **Uniform Interface** | URI, 메서드 등 설계 규칙이 일관됨                  | 학습 비용 감소, API 품질 향상   |
| **Code on Demand**    | 서버가 클라이언트로 실행 가능한 코드(JS 등) 전송 가능 (선택적) | 클라이언트 기능 유연하게 확장      |

#### 📝 설계 규칙 및 HTTP 메서드

| 구성 요소                   | 예시                              | 설명                              |
| ----------------------- | ------------------------------- | ------------------------------- |
| **URI**                 | `/users`, `/posts/123/comments` | 자원(Resource)은 명사로 표현. 복수형 사용    |
| **HTTP 메서드**            | GET, POST, PUT, DELETE          | 자원에 대한 행위는 메서드로 표현              |
| **상태 코드**               | 200, 201, 404, 500 등            | 클라이언트가 요청 결과를 해석할 수 있게 응답 상태 전달 |
| **표현 (Representation)** | JSON, XML                       | 요청/응답 포맷은 일반적으로 JSON 사용         |

| 메서드 | 의미 | 예시 URI | 설명 |
| :---: | :---: | :--- | :--- |
| **GET** | 조회 | `GET /users/1` | 리소스 정보 조회 |
| **POST** | 생성 | `POST /users` | 새로운 리소스 생성 |
| **PUT** | 전체 수정 | `PUT /users/1` | 리소스 전체 교체 (없으면 생성) |
| **PATCH** | 일부 수정 | `PATCH /users/1` | 리소스의 일부 필드만 수정 |
| **DELETE**| 삭제 | `DELETE /users/1` | 리소스 삭제 |

> **💡 Note:** REST의 창시자 로이 필딩은 _"모든 것에 동일한 설계 패턴을 적용하는 것이 꼭 효율적이지는 않다. 핵심은 원활한 소통이 가능한 API를 만드는 것"_이라고 언급함.

---

### 3. DTO (Data Transfer Object)
**계층 간 데이터 교환**을 위해 사용하는, 비즈니스 로직이 없는 **순수 데이터 객체**.
* 주로 `Controller` ↔ `Service` ↔ `Repository` 간 이동 시 사용.

#### ❓ 왜 필요한가?
1.  **관심사의 분리**: Entity는 DB와 매핑되는 핵심 객체이므로, View나 API 요청/응답에 직접 노출하는 것은 보안상 위험하고 불필요한 의존성을 만듦.
2.  **데이터 최적화**: 클라이언트가 필요한 데이터만 선별해서 주고받기 위함.

**JSON 요청 예시**
```json
{
  "title": "게시글 제목",
  "contents": "본문 내용",
  "userId": "abc@example.com"
}
```

**Java 구현 예시 (Inner Class 활용)**
DTO 클래스 내부에 `static class`를 정의하여 관련된 DTO(Create, Update, Response 등)를 묶어서 관리하면 응집도가 높아짐.

```java
public class BoardRequest {

    // 게시글 생성 요청 DTO
    public static class CreateDTO {
        private String userId;
        private String title;
        private String contents;
        private String fileName;
        
        // DTO -> Entity 변환
        public Board toEntity() {
            return Board.builder()
                    .memberEmail(userId)
                    .title(title)
                    .contents(contents)
                    .fileName(fileName)
                    .build();
        }
    }
}
```

---

### 4. Builder Pattern (빌더 패턴)
객체 생성 시 생성자 대신 가독성 좋고 유연하게 객체를 구성할 수 있는 디자인 패턴. Lombok의 `@Builder` 어노테이션을 주로 사용한다.

#### 🆚 생성자 vs 빌더 패턴 비교

| 구분 | 기존 생성자 방식 | 빌더 패턴 |
| :--- | :--- | :--- |
| **가독성** | 파라미터 순서와 타입을 모두 외워야 함 | 메서드 체이닝으로 어떤 필드인지 명확함 |
| **유연성** | 선택적 파라미터 처리가 어려움 (생성자 오버로딩 필요) | 필요한 값만 설정하여 생성 가능 |
| **유지보수**| 필드 추가/삭제 시 기존 코드 수정 영향 큼 | 코드 변경에 유연하게 대처 가능 |

**사용 예시**
```java
// 기존 방식
User user = new User("abc@example.com", "조치호", 25);

// 빌더 패턴 사용
User user = User.builder()
    .email("abc@example.com")
    .name("조치호")
    .age(25)
    .build();
```

---

## 🧑🏻‍💻 코드 예제
> 수업 시간에 작성한 핵심 코드나 직접 변형한 코드

```java
public class User {

    private String name;
    private String email;
    private int age;
	
    private User(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
    }
	
    public static class Builder {
		
        private String name;
        private String email;
        private int age;
		
        public Builder name(String name) {
            this.name = name;
            return this;
        }
		
        public Builder email(String email) {
            this.email = email;
            return this;
        }
		
        public Builder age(int age) {
            this.age = age;
            return this;
        }
		
        public User builder() {
            return new User(this);
        }
    }
}

```

---

## 💣 Trouble Shooting
> 발생한 문제와 해결책

* **문제 상황**: 게시글 작성 시 `org.springframework.dao.DataIntegrityViolationException` 및 `org.h2.jdbc.JdbcSQLIntegrityConstraintViolationException` 발생
* **원인**: 
	- **참조 무결성 위반:** 게시글(Board) 테이블의 `MEMBER_EMAIL` 컬럼은 회원(Member) 테이블의 `EMAIL` 컬럼을 참조하는 외래키(Foreign Key)로 설정되어 있습니다.
	* **데이터 부재:** 사용자가 글 작성 시 입력한 작성자 ID(이메일)인 `'3'`에 해당하는 회원이 `MEMBER` 테이블에 존재하지 않습니다.
	* **DB의 거부:** 데이터베이스는 없는 회원이 글을 작성하는 것을 막기 위해 제약 조건에 따라 저장을 거부했습니다.
* **해결**: **존재하는 회원 ID 사용**

---

## 🌟 잘한 점
> 오늘 하루 스스로 칭찬할 만한 점

* 수업시간에 열심히 따라가고 바로 내용 정리함

---

## ⚠️ 아쉬운 점
> 부족했던 점

* 이해가 잘 되지 않음

---

## 🤔 내일 시도할 점
> 내일 시도하고 싶은 부분

* DB 연결 코드 학습

---

## 💬 한줄평
> 오늘 하루를 한 문장으로 정리

> "다음 개발엔 RESTful API를 적용해봐야겠다."