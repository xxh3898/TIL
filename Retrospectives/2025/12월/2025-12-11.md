# 📅 2025-12-11 (목) 데일리 회고록
**🏷️ Tags:** #Spring #JPA #SpringBoot #PersistenceContext #EntityManager #12월

---

## 📚 학습 내용
> 오늘 공부하면서 새롭게 배운 내용이나 정리한 개념

- **spring-boot-starter-data-jpa**
    - Spring Boot 프로젝트에서 JPA 환경을 쉽고 빠르게 구성할 수 있도록 도와주는 스타터 라이브러리.
    - JPA 설정, 트랜잭션 처리, DataSource, Hibernate(구현체), Spring Data JPA 등을 통합 제공.
    - **주요 구성 요소**
        1. **Hibernate**: JPA의 구현체로 엔티티-테이블 매핑, SQL 생성, 영속성 컨텍스트 관리 담당.
        2. **Spring Data JPA**: Repository 인터페이스만으로 CRUD 및 쿼리 메소드 자동 구현 기능 제공.
        3. **HikariCP**: Spring Boot 2.x 이상의 기본 고성능 커넥션 풀.
        4. **Spring Transaction**: `@Transactional` 어노테이션으로 트랜잭션 관리 자동화.
        5. **DataSourceAutoConfiguration**: `application.yml` 설정 기반으로 DataSource, EntityManagerFactory 등 자동 생성.

- **영속성 관리 (Persistence Management)**
    - 애플리케이션에서 객체(엔티티)의 상태 변화를 추적하고 DB와 동기화하는 과정.
    - **영속성 컨텍스트 (Persistence Context)**: 엔티티를 영구 저장하는 환경(1차 캐시 공간). JPA가 엔티티의 상태를 감지하고 관리함.
    - **엔티티 매니저 (EntityManager)**: 영속성 컨텍스트를 생성하고 엔티티의 저장, 조회, 수정, 삭제를 수행하는 객체.

- **영속성 컨텍스트의 핵심 동작 원리**
    1. **1차 캐시**: 엔티티를 메모리에 캐싱하여 동일한 식별자로 조회 시 DB 접근 없이 반환 (성능 최적화).
    2. **동일성 보장**: 같은 트랜잭션 내에서 조회한 같은 엔티티는 주소값이 같음을 보장 (`a == b` is true).
    3. **트랜잭션 쓰기 지연 (Write-Behind)**: `persist()` 시점에 바로 쿼리를 날리지 않고, `commit()` 시점에 모아둔 쿼리를 한 번에 실행.
    4. **변경 감지 (Dirty Checking)**: 엔티티의 필드 값만 변경하면, 커밋 시점에 스냅샷과 비교해 자동으로 `UPDATE` 쿼리 생성 및 실행.
    5. **지연 로딩 (Lazy Loading)**: 연관된 엔티티를 실제 사용할 때까지 조회를 미루고 프록시 객체로 반환.

- **엔티티 생명주기**
    - **비영속 (New)**: 객체만 생성된 상태, JPA와 무관함.
    - **영속 (Managed)**: `em.persist()` 등으로 영속성 컨텍스트에 저장되어 관리되는 상태.
    - **준영속 (Detached)**: 영속성 컨텍스트에서 분리되어 관리가 중단된 상태.
    - **삭제 (Removed)**: DB에서 삭제가 예약된 상태.

---

## 🧑🏻‍💻 코드 예제
> 수업 시간에 작성한 핵심 코드나 직접 변형한 코드

```java
// EntityManager 사용 예제
EntityManager em = emf.createEntityManager();
em.getTransaction().begin(); // 트랜잭션 시작

// 1. 비영속 상태
Member member = new Member();
member.setId("member1");
member.setName("지원");

// 2. 영속 상태 (1차 캐시 저장, 쓰기 지연 저장소에 쿼리 보관)
em.persist(member);

// 3. 1차 캐시 조회 (DB 쿼리 없이 캐시에서 가져옴)
Member foundMember = em.find(Member.class, "member1");

// 4. 변경 감지 (Dirty Checking) - UPDATE 쿼리 자동 생성 예정
foundMember.setName("변경된 지원");

// 5. 플러시 및 커밋 (이 시점에 INSERT, UPDATE 쿼리 실행)
em.getTransaction().commit();
```

---

## 💣 Trouble Shooting
> 발생한 문제와 해결책

- **문제**: 객체의 값을 수정하고 `update()`와 같은 메소드를 호출해야 DB에 반영될 것이라 생각했는데 그런 메소드가 없어서 혼란스러웠음.
- **해결**: JPA의 **변경 감지(Dirty Checking)** 메커니즘을 이해함. 영속 상태의 엔티티는 값만 바꾸면 트랜잭션이 커밋될 때 알아서 `UPDATE` 쿼리가 나간다는 것을 확인함.

---
## 🌟 잘한 점
> 오늘 하루 스스로 칭찬할 만한 점

- JPA의 내부 동작 원리인 영속성 컨텍스트의 개념을 확실히 정리했다. 단순히 코드를 짜는 것을 넘어, JPA가 왜 SQL을 덜 짜게 해주는지 원리를 이해하려고 노력했다.

---

## ⚠️ 아쉬운 점
> 부족했던 점

- 지연 로딩(Lazy Loading)과 즉시 로딩(Eager Loading)의 실제 동작 차이를 코드로 더 깊게 테스트해보지 못한 점이 아쉽다.

---

## 🤔 내일 시도할 점
> 내일 시도하고 싶은 부분

- 연관 관계 매핑(`@ManyToOne`, `@OneToMany`)을 실습해보고, 지연 로딩으로 인한 N+1 문제를 경험해보고 싶다.

---

## 💬 한줄평
> 오늘 하루를 한 문장으로 정리

> "JPA는 마법이 아니라 영속성 컨텍스트라는 체계적인 시스템 위에서 돌아간다."