# 📅 2025-12-31 (수) 데일리 회고록
**🏷️ Tags:** #SpringBoot #Validation #ExceptionHandling #JWT #Security

---

## 📚 학습 내용
> 오늘 공부하면서 새롭게 배운 내용이나 정리한 개념

**1. Spring Boot Validation (유효성 검사)**
* **개념:** 클라이언트가 전달한 입력값(이메일, 나이 등)이 유효한지 검증하는 과정입니다.
* **주요 어노테이션:**
    * `@NotNull`: 값이 null이면 안 됨 (비어있는 건 허용)
    * `@NotEmpty`: null 불가, 비어있음 불가
    * `@NotBlank`: null, 빈 문자열, 공백만 있는 문자열 모두 불가 (가장 엄격)
    * `@Email`: 이메일 형식 검사, `@Min`/`@Max`: 숫자 범위 제한
* **적용:** DTO 필드에 어노테이션을 붙이고, Controller 파라미터에 `@Valid`를 선언하여 검증을 수행합니다.

**2. 서버의 일관된 예외 처리 (Global Exception Handling)**
* **필요성:** API마다 `try-catch`를 반복하면 코드가 중복되고, 기본 에러 응답(500 Error 등)은 클라이언트가 원인을 파악하기 어렵습니다.
* **구현 방법:** `@RestControllerAdvice`와 `@ExceptionHandler`를 사용하여 프로젝트 전역에서 발생하는 예외를 한 곳에서 통합 처리합니다.
* **표준화:** `ErrorResponse` 객체와 `ErrorCode` Enum을 정의하여 상태 코드, 메시지, 발생 시간 등을 일관된 포맷으로 반환합니다.

**3. JWT (JSON Web Token) 기반 로그인**
* **특징:** 서버가 세션을 유지하지 않는 **Stateless(무상태)** 방식입니다.
* **구조:** Header(헤더), Payload(페이로드), Signature(서명)로 구성됩니다.
* **흐름:**
    1. 로그인 성공 시 서버가 토큰 발급
    2. 클라이언트가 토큰 저장 (LocalStorage 등)
    3. 요청 시 `Authorization: Bearer <Token>` 헤더에 담아 전송
    4. 서버가 서명 검증 후 인증 처리

---

## 🧑🏻‍💻 코드 예제
> 수업 시간에 작성한 핵심 코드나 직접 변형한 코드

**1. 전역 예외 처리기 (GlobalExceptionHandler)**
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 특정 예외(IllegalArgumentException) 처리
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body("잘못된 요청: " + ex.getMessage());
    }

    // 커스텀 예외(UserNotFoundException) 처리 및 ErrorResponse 반환
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex, HttpServletRequest request) {
        ErrorResponse response = ErrorResponse.of(ErrorCode.USER_NOT_FOUND, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
}
```

**2. JWT 토큰 생성 (JwtTokenProvider)**
```java
@Component
public class JwtTokenProvider {
    // ... 필드 및 생성자 생략 ...

    public String generateToken(String userId, String role) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .subject(userId)
                .claim("role", role) // 커스텀 클레임
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(secretKey)
                .compact();
    }
}
```

---

## 💣 Trouble Shooting
> 발생한 문제와 해결책

* **문제:** `@Valid` 검증 실패 시 `MethodArgumentNotValidException`이 발생하는데, 스프링 부트의 기본 응답이 복잡하고 프론트엔드에서 파싱하기 어려웠음.
* **해결:** `@RestControllerAdvice`에서 해당 예외를 잡아, `BindingResult`의 에러 필드(`getFieldErrors`)와 메시지만 추출하여 `Map<String, String>` 형태의 간결한 JSON으로 반환하도록 커스터마이징함.

---

## 🌟 잘한 점
> 오늘 하루 스스로 칭찬할 만한 점

* 2025년의 마지막 날임에도 불구하고, 백엔드 개발의 핵심인 보안(JWT)과 안정성(예외 처리) 로직을 집중적으로 학습했다.
* 단순히 기능을 구현하는 것을 넘어, 유지보수하기 좋은 코드 구조(Enum을 활용한 에러 관리, 전역 처리)를 고민했다.

---

## ⚠️ 아쉬운 점
> 부족했던 점

* JWT의 `Refresh Token` 발급 및 재발급 로직까지는 아직 완벽하게 구현하지 못했다.
* Security 설정(`SecurityConfig`) 부분에서 필터 체인의 동작 원리가 다소 복잡하게 느껴져 추가 학습이 필요하다.

---

## 🤔 내일 시도할 점
> 내일 시도하고 싶은 부분

* 개인 프로젝트(Cubing-Hub)의 로그인 API에 오늘 배운 JWT 방식을 적용하여 회원가입/로그인 구현하기.
* `ErrorCode` Enum에 프로젝트에서 발생할 수 있는 비즈니스 예외 상황들을 미리 정의해두기.

---

## 💬 한줄평
> 오늘 하루를 한 문장으로 정리

> "견고한 서버를 만들기 위해선 '정상 로직'만큼이나 '예외 상황'을 다루는 기술이 중요하다는 것을 깨달은 2025년의 마지막 날!"